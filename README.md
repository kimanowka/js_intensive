# JS intensive of Aston

## ДЗ№1

1. С помощью встроенной браузерной функции prompt поочерёдно ввести два значения. Если оба значения являются валидными числами, то вывести в консоли результат в виде первого числа в системе счисления второго.
   Если хотя бы одно из введённых значений является некорректным числом, вывести в консоли сообщение: "Некорректный ввод!" и завершить программу.

   > Примеры:
   > Вводим 10 и 2, получаем 1010
   > Вводим 872 и 8, получаем 1550
   > Вводим 2 и 'abc', получаем "Некорректный ввод!"

2. С помощью встроенной браузерной функции prompt поочерёдно ввести два значения. Если первое значение является невалидным числом, вывести в консоли сообщение: "Некорректный ввод!" и завершить программу. В ином случае, если второе значение является невалидным числом вывести такое же сообщение об ошибке и завершить программу. Если оба значения являются валидными числами, то вывести в консоль результат в виде: "Ответ: [сумма двух чисел], [частное двух чисел]."
   > Примеры:
   > Вводим 10 и 2, получаем "Ответ: 12, 5."
   > Вводим 872 и 8, получаем "Ответ: 880, 109."
   > Вводим 'abc', получаем "Некорректный ввод!"

## ДЗ№2

1. Написать свою функцию для глубокого копирования объектов. При этом алгоритм должен осуществляться вручную (никаких вариантов с использованием готовых библиотек или JSON.stringify() + JSON.parse(), за это сразу 0 баллов за первую задачу). Функция должна называться makeObjectDeepCopy. Это важно, т.к. проверять буду тестами. Принимать функция должна один параметр - объект, копию которого нужно сделать.

2. Написать функцию, которая принимает три аргумента: массив чисел, первое значение интервала, второе значение интервала. Результатом вызова функции должен быть массив из значений переданного массива (в качестве первого параметра), которые входят в этот интервал (концы включая). Если в качестве первого параметра передан не массив или массив, содержащий не только числа - кидать ошибку (throw new Error(...)). Если хотя бы одно из значений интервала (имеются ввиду параметры функции selectFromInterval) - невалидное число!, то также кидать ошибку.
   Если первое значение интервала < второго (имеются ввиду параметры функции selectFromInterval), то считать за интервал значения от первого до второго, в ином случае - от второго до первого.
   Функция должна называться selectFromInterval. Это важно, т.к. проверять буду тестами.

   > Примеры:
   > Вызываем функцию: selectFromInterval([1,3,5], 5, 2)
   > Получаем результат: [3,5]
   > Вызываем функцию: selectFromInterval([-2, -15, 0, 4], -13, -5)
   > Получаем результат: []
   > Вызываем функцию: selectFromInterval(['aaa'], 2, 3)
   > Получаем результат: Ошибка!

3. Создать обычный объект и сделать его итерируемым. При этом итерация должна происходить следующим образом:
   Должны поочерёдно проходиться все значения от свойства объекта from, до свойства to. (в случае если to < from - должна возникать ошибка).
   Если to или from не указаны ИЛИ to или from не являются числами, должна возникать ошибка. Объект должен называться myIterable. Это важно, т.к. проверять буду тестами.
   > Примеры:
   > const myIterable = { from: 1, to: 4 };
   > for (let item of myIterable) {
   > console.log(item); // 1, 2, 3, 4
   > }

const myIterable = { from: 'aaa', to: 4 };
for (let item of myIterable) { // Ошибка!
console.log(item);
}

## ДЗ№3

1. Написать свою реализацию встроенной функции массивов filter. Назвать функцию myFilter и сделать так, чтобы любой массив мог использовать данную функцию как "родную". В качестве параметров он должен принимать callback-функцию и как необязательный параметр объект, который будет использован в качестве this в рамках внутренних вызовов данной callback-функции.
   В конечном итоге ваша реализация myFilter должна работать точно также как и встроенный метод filter. Callback-функция, переданная в качестве параметра, также должна вызываться с теми же параметрами, что и оригинал (элемент, индекс, массив).

## ДЗ№4

Написать функцию createDebounceFunction. Она должна принимать два аргумента: callback-функцию и задержку в миллисекундах. Данная функция должна возвращать новую функцию, вызывающую callback-функцию с задержкой в переданное количество миллисекунд. ПРИ ЭТОМ! Если за то время, пока внутрення callback-функция ждёт своего вызова, наша созданная функция вызывается ещё раз, то "счётчик" времени должен сбрасываться и начинаться заново (т.е. вызова внутренней функции произойти не должно).

> Пример:
> const log100 = () => console.log(100);
> const debounceLog100 = createDebounceFunction(log100, 1000);
> debounceLog100();
> setTimeout(debounceLog100, 200); // так как задержка в 1000мс и новый вызов этой же функции происходит через 200 миллисекунд, то таймер запускается заново
> setTimeout(debounceLog100, 400); // снова сбрасываем таймер ещё через 200 миллисекунд

Вывод в консоли значения 100 примерно через 1000мс + 200мс + 200мс

## ДЗ№5

Создать класс Calculator. Конструктор класса должен принимать два валидных числа, иначе (если параметра не два или хотя бы один из них невалидный number) бросать ошибку (throw new Error('')). Данный класс должен иметь методы setX, setY, logSum, logMul, logSub, logDiv.

- setX(num) - задаёт первому из чисел новое значение. Кидать ошибку если параметр не передан или является невалидным числом;
- setY(num) - задаёт второму из чисел новое значение. Кидать ошибку если параметр не передан или является невалидным числом;
- logSum() - выводит в консоль сумму двух наших чисел внутри класса;
- logMul() - выводит в консоль произведение двух наших чисел внутри класса;
- logSub() - выводит в консоль разность двух наших чисел внутри класса;
- logDiv() - выводит в консоль частное двух наших чисел внутри класса ИЛИ кидает ошибку, если второе число (Y)
  равняется нулю.
